# Невскрываемое шифрование

[На главную](../../README.md)

Под "невскрываемостью" здесь подразумевается отсутствие возможности рассчитать по каким-то данным ключ, так как он получается путём применения логической операции XOR к двум составляющим: фиктивным данным (случайной последовательности символов) и, собственно, исходным данным.

Значит, первой задачей у нас будет: получение данных в заданной последовательности. Вторая - шифрование и дешифрование.

## Генерация фиктивных данных

Три критерия:
+ *ФД должны быть* той же длины, что и исходные
+ *ФД должны быть* действительно случайными
+ *ФД должны быть* полностью секретными

Со вторым пунктом у нас имеются некоторые трудности: мы не можем на большинстве машин сгенерировать действительно случайные данные. Однако мы будем держать это в уме, но для примера не станем идти на особые ухищрения и воспользуемся пакетом ***secrets***.

Функция `random_key()` генерирует случайный ключ. В биты мы переводим так как это позволяет удобнее работать с логическими операциями.

## Шифрование и дешифрование

Для объединения фиктивных и исходных данных задействуем операцию *exclusive or* (^) - XOR (`true` толко тогда, когда один из операндов `true`):

```python
0^1 # 1
1^0 # 1
1^1 # 0
0^0 # 0
```

Полезное свойство в том, что при объединении результата с одним из операндов, получится второй операнд. Важно при использовании типизированного стиля не перепутать типы. 

При расшифровке мы прибавляем к 7 к длине расшифрованных данных, прежде чем использовать целочисленное деление на 8 (длина байта), чтобы гарантировать округление и избежать ошибки. И таким образом мы шифруем и дешифруем одну и ту же строку в Unicode.

Для более полной картины, можно посмотреть [статью](https://habr.com/ru/post/444176/) про виды шифрования на Хабре.