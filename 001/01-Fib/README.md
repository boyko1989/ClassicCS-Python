# Ряд Фибоначчи

Это последовательность чисел, в которой любое число, кроме первого и второго, является суммой двух предыдущих.

Можно использовать следующую формулу:

`fib(n) = fib(n - 1) + fib(n - 2)`

## Рекурсия

> Здесь использован неизвестный для меня вид записи:
> 
> ```python
> def fib1(n: int) -> int:
>     return fib1(n - 1) + fib1(n - 2)
> ```
> Что касается записи `n: int` - это понятно, но относительно стрелочики могу предположить, что это возвращаемое значение.

Ясно, что этот код приведёт к ошибке, а конкретно к `RecursionError: maximum recursion depth exceeded`. Проблема в отсутствии базового случая и, как следствие, бесконечной рекурсии. Вообще, понятие *базового случая* относится к рекурсивным вызовам. Нужно определить куда "сядет" наш самолёт рекурсии: в устной речи это звучит как "до тех пор, пока..."

"Где" будет находиться *базовый случай* определяет возрастанием или убыванием функции, которая работает в рекурсивном режиме. Это могут быть не только числовые последовательности, но и такие сущности как выпадающее меню, где каждый пункт имеет своего родителя **кроме** первого (или корневого). Значит для каждого пункта нужно вызывать условную функцию `get_parrent()` до тех пор пока `parrent` будет либо равен `0` или `None`. 

## Мемоизация

Метод, при котором сохраняются результаты выполненных вычислений.

У рекурсии очень большой недостаток: она медленная. Если это не заметно на малых числах, то по мере возрастания в разы падает скорость работы программы. Однако даже на малых числах можно заметить, что выполняется ОЧЕНЬ много повторяющихся вычислений.

Стоит построить дерево вызовов и станет очевидно, что наша функция `fib1()` вызывается часто с одними и теми же параметрами.
